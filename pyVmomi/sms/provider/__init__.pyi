from typing import List
from enum import Enum
from pyVmomi import sms, vim, vmodl
from pyVmomi.VmomiSupport import ManagedObject, long


class Provider(ManagedObject):
    def QueryProviderInfo(self) -> ProviderInfo: ...


class VasaProvider(Provider):
    def Sync(self, arrayId: str) -> sms.Task: ...
    def RefreshCertificate(self) -> sms.Task: ...
    def RevokeCertificate(self) -> sms.Task: ...
    def Reconnect(self) -> sms.Task: ...
    def QueryReplicationPeer(self, faultDomainId: List[vim.vm.replication.FaultDomainId]) -> List[sms.storage.replication.QueryReplicationPeerResult]: ...
    def QueryReplicationGroup(self, groupId: List[vim.vm.replication.ReplicationGroupId]) -> List[sms.storage.replication.GroupOperationResult]: ...
    def QueryPointInTimeReplica(self, groupId: List[vim.vm.replication.ReplicationGroupId], queryParam: sms.storage.replication.QueryPointInTimeReplicaParam) -> List[sms.storage.replication.GroupOperationResult]: ...
    def TestFailoverReplicationGroupStart(self, testFailoverParam: sms.storage.replication.TestFailoverParam) -> sms.Task: ...
    def TestFailoverReplicationGroupStop(self, groupId: List[vim.vm.replication.ReplicationGroupId], force: bool) -> sms.Task: ...
    def PromoteReplicationGroup(self, promoteParam: sms.storage.replication.PromoteParam) -> sms.Task: ...
    def SyncReplicationGroup(self, groupId: List[vim.vm.replication.ReplicationGroupId], pitName: str) -> sms.Task: ...
    def PrepareFailoverReplicationGroup(self, groupId: List[vim.vm.replication.ReplicationGroupId]) -> sms.Task: ...
    def FailoverReplicationGroup(self, failoverParam: sms.storage.replication.FailoverParam) -> sms.Task: ...
    def ReverseReplicateGroup(self, groupId: List[vim.vm.replication.ReplicationGroupId]) -> sms.Task: ...
    def QueryActiveAlarm(self, alarmFilter: AlarmFilter) -> AlarmResult: ...


class AlarmFilter(vmodl.DynamicData):
    @property
    def alarmStatus(self) -> str: ...
    @property
    def alarmType(self) -> str: ...
    @property
    def entityType(self) -> str: ...
    @property
    def entityId(self) -> List[object]: ...
    @property
    def pageMarker(self) -> str: ...


class AlarmResult(vmodl.DynamicData):
    @property
    def storageAlarm(self) -> List[sms.storage.StorageAlarm]: ...
    @property
    def pageMarker(self) -> str: ...


class ProviderInfo(vmodl.DynamicData):
    @property
    def uid(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def description(self) -> str: ...
    @property
    def version(self) -> str: ...


class ProviderSpec(vmodl.DynamicData):
    @property
    def name(self) -> str: ...
    @property
    def description(self) -> str: ...


class VasaProviderInfo(ProviderInfo):
    @property
    def url(self) -> str: ...
    @property
    def certificate(self) -> str: ...
    @property
    def status(self) -> str: ...
    @property
    def statusFault(self) -> vmodl.MethodFault: ...
    @property
    def vasaVersion(self) -> str: ...
    @property
    def namespace(self) -> str: ...
    @property
    def lastSyncTime(self) -> str: ...
    @property
    def supportedVendorModelMapping(self) -> List[VasaProviderInfo.SupportedVendorModelMapping]: ...
    @property
    def supportedProfile(self) -> List[str]: ...
    @property
    def supportedProviderProfile(self) -> List[str]: ...
    @property
    def relatedStorageArray(self) -> List[VasaProviderInfo.RelatedStorageArray]: ...
    @property
    def providerId(self) -> str: ...
    @property
    def certificateExpiryDate(self) -> str: ...
    @property
    def certificateStatus(self) -> str: ...
    @property
    def serviceLocation(self) -> str: ...
    @property
    def needsExplicitActivation(self) -> bool: ...
    @property
    def maxBatchSize(self) -> long: ...
    @property
    def retainVasaProviderCertificate(self) -> bool: ...
    @property
    def arrayIndependentProvider(self) -> bool: ...
    @property
    def type(self) -> str: ...
    @property
    def category(self) -> str: ...
    @property
    def priority(self) -> int: ...
    @property
    def failoverGroupId(self) -> str: ...


    class RelatedStorageArray(vmodl.DynamicData):
        @property
        def arrayId(self) -> str: ...
        @property
        def active(self) -> bool: ...
        @property
        def manageable(self) -> bool: ...
        @property
        def priority(self) -> int: ...


    class SupportedVendorModelMapping(vmodl.DynamicData):
        @property
        def vendorId(self) -> str: ...
        @property
        def modelId(self) -> str: ...


    class Category(Enum):
        internal = "internal"
        external = "external"


    class CertificateStatus(Enum):
        valid = "valid"
        expirySoftLimitReached = "expirySoftLimitReached"
        expiryHardLimitReached = "expiryHardLimitReached"
        expired = "expired"
        invalid = "invalid"


    class ProviderProfile(Enum):
        ProfileBasedManagement = "ProfileBasedManagement"
        Replication = "Replication"


    class Type(Enum):
        PERSISTENCE = "PERSISTENCE"
        DATASERVICE = "DATASERVICE"
        UNKNOWN = "UNKNOWN"


    class VasaProviderProfile(Enum):
        blockDevice = "blockDevice"
        fileSystem = "fileSystem"
        capability = "capability"


    class VasaProviderStatus(Enum):
        online = "online"
        offline = "offline"
        syncError = "syncError"
        unknown = "unknown"
        connected = "connected"
        disconnected = "disconnected"


class VasaProviderSpec(ProviderSpec):
    @property
    def username(self) -> str: ...
    @property
    def password(self) -> str: ...
    @property
    def url(self) -> str: ...
    @property
    def certificate(self) -> str: ...


class VmodlVasaProviderSpec():


    class AuthenticationType(Enum):
        LoginByToken = "LoginByToken"
        UseSessionId = "UseSessionId"